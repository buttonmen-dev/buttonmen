<?php

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2012-12-21 at 15:13:07.
 */
class BMUtilityXCYIteratorTest extends PHPUnit\Framework\TestCase {
    /**
     * @var BMUtilityXCYIterator
     */
    protected $object;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp() : void
    {
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown() : void
    {
    }

    /**
     * @covers BMUtilityXCYIterator::setPosition
     * @covers BMUtilityXCYIterator::rewind
     * @covers BMUtilityXCYIterator::current
     * @covers BMUtilityXCYIterator::key
     * @covers BMUtilityXCYIterator::next
     * @covers BMUtilityXCYIterator::valid
     */
    public function testBMUtilityXCYIterator() {
        // Treating the iterator as a black box, rather than trying to
        // test its individual methods. If it returns the right
        // results, it's right.

        // Test for the right number of results
        //
        // Number of ways to choose Y items from a set of X items is
        // X! / ( Y! * (X-Y)! )

        $fiveArray = array('A', 'B', 'C', 'D', 'E');
        $eightArray = array('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H');

        $iter = new BMUtilityXCYIterator($fiveArray, 1);
        $count = 0;

        foreach ($iter as $key => $item) {
            $count++;
            $this->assertEquals(1, count($item));
        }
        $this->assertEquals(5, $count);

        $iter = new BMUtilityXCYIterator($fiveArray, 2);
        $count = 0;

        foreach ($iter as $key => $item) {
            $count++;
            $this->assertEquals(2, count($item));
        }
        $this->assertEquals(10, $count);


        $iter = new BMUtilityXCYIterator($fiveArray, 3);
        $count = 0;

        foreach ($iter as $key => $item) {
            $count++;
            $this->assertEquals(3, count($item));
        }
        $this->assertEquals(10, $count);

        $iter = new BMUtilityXCYIterator($fiveArray, 4);
        $count = 0;

        foreach ($iter as $key => $item) {
            $count++;
            $this->assertEquals(4, count($item));
        }
        $this->assertEquals(5, $count);

        $iter = new BMUtilityXCYIterator($fiveArray, 5);
        $count = 0;

        foreach ($iter as $key => $item) {
            $count++;
            $this->assertEquals(5, count($item));
        }
        $this->assertEquals(1, $count);



        $iter = new BMUtilityXCYIterator($eightArray, 4);
        $count = 0;

        foreach ($iter as $key => $item) {
            $count++;
            $this->assertEquals(4, count($item));
        }
        $this->assertEquals(70, $count);

        $iter = new BMUtilityXCYIterator($eightArray, 5);
        $count = 0;

        foreach ($iter as $key => $item) {
            $count++;
            $this->assertEquals(5, count($item));
        }
        $this->assertEquals(56, $count);

        // Test that the results are correct

        // Test correct distribution

        $hitcounts = array();
        foreach ($eightArray as $key) {
            $hitcounts[$key] = 0;
        }

        $iter = new BMUtilityXCYIterator($eightArray, 5);
        $count = 0;

        foreach ($iter as $key => $item) {
            foreach ($item as $hit) {
                $hitcounts[$hit]++;
            }
            $count++;
        }
        $this->assertEquals(56, $count);

        // Each item will appear an equal number of times
        $target = $hitcounts['A'];

        foreach ($hitcounts as $key => $hit) {
            $this->assertEquals($target, $hitcounts[$key]);
        }

        // we have the right number of results, and the right
        // distribution. Now, we have to ensure that each correct
        // combination apears exactly once

        // generate the possible combinations in an inefficient, but
        // easy to prove correct, manner

        $combinations = array();
        $keycombinations = array();
        foreach ($eightArray as $ikey => $i) {
            foreach ($eightArray as $jkey => $j) {
                foreach ($eightArray as $kkey => $k) {
                    if ($k == $i || $k == $j || $i == $j) { continue; }
                    $tmp = array($i, $j, $k);
                    sort($tmp);
                    $key = join($tmp);
                    // There will be duplications, but this eliminates them
                    $combinations[$key] = 0;

                    // and test the iteration keys as well
                    $tmp = array($ikey+1, $jkey+1, $kkey+1);
                    sort($tmp);
                    $key = join($tmp);
                    // There will be duplications, but this eliminates them
                    $keycombinations[$key] = 0;
                }

            }

        }
        $this->assertEquals(56, count($combinations));

        $iter = new BMUtilityXCYIterator($eightArray, 3);

        foreach ($iter as $key => $item) {
             $combinations[join($item)]++;
             // get the key's digits in the same order as
             // $keycombination's keys
             $tmp = str_split($key);
             sort($tmp);
             $keycombinations[join($tmp)]++;
        }

        // Each combination should have been visited exactly once
        foreach ($combinations as $x) {
            $this->assertEquals(1, $x);
        }
        foreach ($keycombinations as $x) {
            $this->assertEquals(1, $x);
        }
    }
}
