<?php

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2012-12-11 at 13:27:50.
 */
class BMGameTest extends PHPUnit_Framework_TestCase {

    /**
     * @var BMGame
     */
    protected $object;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp() {
        $this->object = new BMGame;
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown() {

    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_start_game() {
        // the first player always has to be set before advancing the game
        $this->object->gameState = BMGameState::startGame;
        try {
            $this->object->do_next_step();
        }
        catch (UnexpectedValueException $expected) {
        }

        // players other than the first can be unspecified
        $this->object->gameState = BMGameState::startGame;
        $this->object->playerIdArray = array(123, 0);
        $this->object->do_next_step();

        // buttons can be unspecified
        $this->object->gameState = BMGameState::startGame;
        $this->object->playerIdArray = array(123, 456);
        $this->object->do_next_step();

    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_apply_handicaps() {
        $this->object->gameState = BMGameState::applyHandicaps;
        $this->object->do_next_step();
        $this->assertEquals($this->object->gameScoreArrayArray,
                            array(array('W' => 0, 'L' => 0, 'T' => 0),
                                  array('W' => 0, 'L' => 0, 'T' => 0)));
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_choose_auxiliary_dice() {
        $this->object->gameState = BMGameState::chooseAuxiliaryDice;
        $button1 = new BMButton;
        $button2 = new BMButton;
        $recipe1 = '(4) (8) (12) (30)';
        $recipe2 = '(6) (12) (20) (20)';
        $button1->load($recipe1);
        $button2->load($recipe2);
        $this->object->buttonArray = array($button1, $button2);
        $this->object->do_next_step();
        $this->assertEquals($recipe1, $this->object->buttonArray[0]->recipe);
        $this->assertEquals($recipe2, $this->object->buttonArray[1]->recipe);

        $this->object->gameState = BMGameState::chooseAuxiliaryDice;
        $button1 = new BMButton;
        $button2 = new BMButton;
        $recipe1 = '(4) (8) (12) +(30)';
        $recipe2 = '(6) (12) (20) (20)';
        $button1->load($recipe1);
        $button2->load($recipe2);
        $this->object->buttonArray = array($button1, $button2);
        $this->object->do_next_step();
        $this->assertEquals('(4) (8) (12) (30)', $this->object->buttonArray[0]->recipe);
        $this->assertEquals('(6) (12) (20) (20) (30)', $this->object->buttonArray[1]->recipe);

        $this->object->gameState = BMGameState::chooseAuxiliaryDice;
        $button1 = new BMButton;
        $button2 = new BMButton;
        $recipe1 = '(4) (8) (12) +(30)';
        $recipe2 = '(6)+ (12) (20) (20)';
        $button1->load($recipe1);
        $button2->load($recipe2);
        $this->object->buttonArray = array($button1, $button2);
        $this->object->do_next_step();
        $this->assertEquals('(4) (8) (12) (30) (6)', $this->object->buttonArray[0]->recipe);
        $this->assertEquals('(12) (20) (20) (30) (6)', $this->object->buttonArray[1]->recipe);
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_load_dice_into_buttons() {
//        $this->object->gameState = BMGameState::loadDiceIntoButtons;
//
//        $button1 = new BMButton;
//        $button2 = new BMButton;
//        $recipe1 = '(4) (8) (12) (30)';
//        $recipe2 = '(6) (12) (20) (20)';
//        $button1->load_from_recipe($recipe1);
//        $button2->load_from_recipe($recipe2);
//        $dieArray1 = $button1->dieArray;
//        $dieArray2 = $button2->dieArray;
//        $button1->dieArray = array();
//        $button2->dieArray = array();
//        $this->object->buttonArray = array($button1, $button2);
//        $this->object->do_next_step();
//
//        $this->assertEquals($dieArray1, $this->object->buttonArray[0]->dieArray);
//        $this->assertEquals($dieArray2, $this->object->buttonArray[1]->dieArray);
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_add_available_dice_to_game() {
        $this->object->gameState = BMGameState::addAvailableDiceToGame;
        $button1 = new BMButton;
        $button2 = new BMButton;
        $recipe1 = '(4) (8) (12) (30)';
        $recipe2 = '(6) (12) (20) (20)';
        $button1->load($recipe1);
        $button2->load($recipe2);
        $this->object->buttonArray = array($button1, $button2);
        $this->object->do_next_step();

        // synchronise values
        $dieArray1 = array();
        foreach ($this->object->activeDieArrayArray[0] as $dieIdx => $die) {
            $tempDie = clone $button1->dieArray[$dieIdx];
            $dieArray1[] = clone $tempDie;
        }

        $dieArray2 = array();
        foreach ($this->object->activeDieArrayArray[1] as $dieIdx => $die) {
            $tempDie = clone $button2->dieArray[$dieIdx];
            $dieArray2[] = clone $tempDie;
        }

        $this->assertEquals(array($dieArray1, $dieArray2),
                            $this->object->activeDieArrayArray);
        $this->assertNull($this->object->activeDieArrayArray[0][0]->value);
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_specify_dice() {
        // no swing dice
        $this->object->gameState = BMGameState::specifyDice;
        $button1 = new BMButton;
        $button2 = new BMButton;
        $recipe1 = '(4) (8) (12) (30)';
        $recipe2 = '(6) (12) (20) (20)';
        $button1->load($recipe1);
        $button2->load($recipe2);
        $this->object->activeDieArrayArray = array($button1->dieArray,
                                                   $button2->dieArray);
        $this->object->swingRequestArrayArray = array(array(), array());
        $this->object->do_next_step();
        $this->assertEquals(array(FALSE, FALSE), $this->object->waitingOnActionArray);
        $this->assertEquals(array(array(), array()), $this->object->swingValueArrayArray);

        // with swing dice
        $this->object->gameState = BMGameState::specifyDice;
        $button1 = new BMButton;
        $button2 = new BMButton;
        $recipe1 = '(4) (8) (12) (X)';
        $recipe2 = '(6) (12) (Y) (Y)';
        $button1->load($recipe1);
        $button2->load($recipe2);

        $this->assertTrue($button1->dieArray[3] instanceof BMDieSwing);
        $this->assertTrue($button2->dieArray[2] instanceof BMDieSwing);
        $this->assertTrue($button2->dieArray[3] instanceof BMDieSwing);
        $this->assertTrue($button1->dieArray[3]->needsValue);
        $this->assertTrue($button2->dieArray[2]->needsValue);
        $this->assertTrue($button2->dieArray[3]->needsValue);

        $this->object->activeDieArrayArray = array($button1->dieArray,
                                                   $button2->dieArray);

        $this->assertTrue($this->object->activeDieArrayArray[0][3] instanceof BMDieSwing);
        $this->assertTrue($this->object->activeDieArrayArray[1][2] instanceof BMDieSwing);
        $this->assertTrue($this->object->activeDieArrayArray[1][3] instanceof BMDieSwing);
        $this->assertTrue($this->object->activeDieArrayArray[0][3]->needsValue);
        $this->assertTrue($this->object->activeDieArrayArray[1][2]->needsValue);
        $this->assertTrue($this->object->activeDieArrayArray[1][3]->needsValue);

        $this->object->swingRequestArrayArray =
            array(array('X'=>array($this->object->activeDieArrayArray[0][3])),
                  array('Y'=>array($this->object->activeDieArrayArray[1][2],
                                   $this->object->activeDieArrayArray[1][3])));
        $this->object->do_next_step();

        $this->assertEquals(array(TRUE, TRUE), $this->object->waitingOnActionArray);
        $this->assertEquals(array(array('X'=>NULL), array('Y'=>NULL)),
                            $this->object->swingValueArrayArray);

        $this->object->swingValueArrayArray = array(array('X'=>30), array('Y'=>1));
        $this->object->do_next_step();
        $this->assertEquals(array(array(), array('Y'=>1)),
                            $this->object->swingValueArrayArray);

        $this->object->swingValueArrayArray = array(array('X'=>5), array('Y'=>20));
        $this->object->do_next_step();
        $this->assertEquals(array(array('X'=>5), array('Y'=>20)),
                            $this->object->swingValueArrayArray);

        $this->assertTrue($this->object->activeDieArrayArray[0][3] instanceof BMDieSwing);
        $this->assertTrue($this->object->activeDieArrayArray[1][2] instanceof BMDieSwing);
        $this->assertTrue($this->object->activeDieArrayArray[1][3] instanceof BMDieSwing);
        $this->assertFalse($this->object->activeDieArrayArray[0][3]->needsValue);
        $this->assertFalse($this->object->activeDieArrayArray[1][2]->needsValue);
        $this->assertFalse($this->object->activeDieArrayArray[1][3]->needsValue);

        $this->assertEquals(4,  $this->object->activeDieArrayArray[0][0]->max);
        $this->assertEquals(8,  $this->object->activeDieArrayArray[0][1]->max);
        $this->assertEquals(12, $this->object->activeDieArrayArray[0][2]->max);
        $this->assertEquals(5,  $this->object->activeDieArrayArray[0][3]->max);
        $this->assertEquals(6,  $this->object->activeDieArrayArray[1][0]->max);
        $this->assertEquals(12, $this->object->activeDieArrayArray[1][1]->max);
        $this->assertEquals(20, $this->object->activeDieArrayArray[1][2]->max);
        $this->assertEquals(20, $this->object->activeDieArrayArray[1][3]->max);
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_determine_initiative() {
        $this->object->gameState = BMGameState::determineInitiative;
        $die1 = BMDie::create(1, array());
        $die1->value = 1;
        $die2 = BMDie::create(2, array());
        $die2->value = 2;
        $this->object->activeDieArrayArray = array(array($die1), array($die2));
        $this->object->do_next_step();
        $this->assertEquals(0, $this->object->playerWithInitiativeIdx);

        $this->object->gameState = BMGameState::determineInitiative;
        $die1 = BMDie::create(2, array());
        $die1->value = 2;
        $die2 = BMDie::create(1, array());
        $die2->value = 1;
        $this->object->activeDieArrayArray = array(array($die1), array($die2));
        $this->object->do_next_step();
        $this->assertEquals(1, $this->object->playerWithInitiativeIdx);

        $this->object->gameState = BMGameState::determineInitiative;
        $die1 = BMDie::create(1, array());
        $die1->value = 1;
        $die2 = BMDie::create(1, array());
        $die2->value = 1;
        $this->object->activeDieArrayArray = array(array($die1), array($die2));
        $playerWithInitiativeStore = array();
        for ($runIdx = 1; $runIdx <= 50; $runIdx++) {
            unset($this->object->playerWithInitiativeIdx);
            $this->object->do_next_step();
            $playerWithInitiativeStore[] = $this->object->playerWithInitiativeIdx;
        }
        $this->assertGreaterThanOrEqual(0, min($playerWithInitiativeStore));
        $this->assertLessThanOrEqual(1, max($playerWithInitiativeStore));
        $this->assertTrue(in_array(0, $playerWithInitiativeStore));
        $this->assertTrue(in_array(1, $playerWithInitiativeStore));

        $this->object->gameState = BMGameState::determineInitiative;
        $die1 = BMDie::create(20, array());
        $die1->value = 10;
        $die2 = BMDie::create(20, array());
        $die2->value = 12;
        $die3 = BMDie::create(20, array());
        $die3->value = 10;
        $die4 = BMDie::create(20, array());
        $die4->value = 11;
        $this->object->activeDieArrayArray = array(array($die1, $die2),
                                                   array($die3, $die4));
        $playerWithInitiativeStore = array();
        for ($runIdx = 1; $runIdx <= 50; $runIdx++) {
            unset($this->object->playerWithInitiativeIdx);
            $this->object->do_next_step();
            $playerWithInitiativeStore[] = $this->object->playerWithInitiativeIdx;
        }
        $this->assertFalse(in_array(0, $playerWithInitiativeStore));
        $this->assertTrue(in_array(1, $playerWithInitiativeStore));
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_start_round() {
        $this->object->gameState = BMGameState::startRound;
        try {
            $this->object->do_next_step();
            fail('The player who has won initiative must already have been determined.');
        }
        catch (LogicException $expected) {
        }

        $this->object->gameState = BMGameState::startRound;
        $this->object->playerWithInitiativeIdx = 0;
        $this->object->do_next_step();
        $this->assertEquals($this->object->playerWithInitiativeIdx,
                            $this->object->activePlayerIdx);

        $this->object->gameState = BMGameState::startRound;
        $this->object->playerWithInitiativeIdx = 1;
        $this->object->do_next_step();
        $this->assertEquals($this->object->playerWithInitiativeIdx,
                            $this->object->activePlayerIdx);
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_start_turn() {
        $this->object->gameState = BMGameState::startTurn;
        $this->object->activePlayerIdx = 0;

        $die1ValueStore = array();
        $die2ValueStore = array();
        $die4ValueStore = array();
        for ($runIdx = 0; $runIdx <= 50; $runIdx++) {
            $die1 = BMDie::create(30, array());
            $die2 = BMDie::create(20, array());
            $die3 = BMDie::create(16, array());
            $die4 = BMDie::create(50, array());
            $die1->value = 1;
            $die2->value = 3;
            $die3->value = 2;
            $die4->value = 1;
            $this->object->activeDieArrayArray = array(array($die1, $die2),
                                                       array($die3, $die4));
            $this->object->attack = array(0, 1, array(1), array(0), 'power');
            $this->object->do_next_step();
            $die1ValueStore[] = $die1->value;
            $die2ValueStore[] = $die2->value;
            $die4ValueStore[] = $die4->value;
        }
        // check that only dice involved in the attack have rerolled
        $this->assertEquals(1, max($die1ValueStore));
        $this->assertTrue(count(array_flip($die2ValueStore)) > 1);
        $this->assertTrue($die3->captured);
        $this->assertEquals(1, max($die4ValueStore));

        $dieArrayArray = $this->object->activeDieArrayArray;
        // set values manually
        $dieArrayArray[0][0]->value = 5;
        $dieArrayArray[0][1]->value = 1;
        $dieArrayArray[1][0]->value = 4;

        $this->assertEquals(5, $this->object->activeDieArrayArray[0][0]->value);
        $this->assertEquals(1, $this->object->activeDieArrayArray[0][1]->value);
        $this->assertEquals(4, $this->object->activeDieArrayArray[1][0]->value);

        $this->object->attack = array(0, 1, array(0), array(0), "power");
        $this->object->gameState = BMGameState::startTurn;
        $this->object->do_next_step();

        $this->assertEquals(2, count($this->object->activeDieArrayArray[0]));
        $this->assertEquals(0, count($this->object->activeDieArrayArray[1]));
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_end_turn() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
                'This test has not been implemented yet.'
        );
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_end_round() {
        // test for end turn with one player without dice
        $this->object->playerIdArray = array(12345, 54321);
        $this->object->gameState = BMGameState::endRound;
        $die = BMDie::create_from_string('12');
        $this->object->activeDieArrayArray = array(array(), array($die));
        $this->object->swingValueArrayArray = array(array('X' => 5), array('Y' => 2));
        $this->object->maxWins = 6;
        $this->object->gameScoreArrayArray = array(array(4,2,1), array(2,4,1));
        $this->object->playerWithInitiativeIdx = 1;
        $this->object->activePlayerIdx = 1;
        $this->object->passStatusArray = array(FALSE, FALSE);
        $this->object->do_next_step();
        $this->assertFalse(isset($this->object->activePlayerIdx));
        $this->assertFalse(isset($this->object->playerWithInitiativeIdx));
        $this->assertEquals(array(array('W' => 4, 'L' => 3, 'D' => 1),
                                  array('W' => 3, 'L' => 4, 'D' => 1)),
                            $this->object->gameScoreArrayArray);
//        $this->assertEquals(array(array(), array('Y' => 2)));

        // test for draw


        // test for all pass at end of round
        $this->object->playerIdArray = array(12345, 54321);
        $this->object->playerWithInitiativeIdx = 1;
        $this->object->activePlayerIdx = 0;
        $die1 = BMDie::create(12);
        $die2 = BMDie::create(15);
        $this->object->activeDieArrayArray = array(array($die1), array($die2));
        $this->object->capturedDieArrayArray = array(array(), array());
        $this->object->passStatusArray = array(TRUE, TRUE);
//        $this->object->roundScoreArray = array(26.5, -26.5);
        $this->object->maxWins = 3;
        $this->object->gameScoreArrayArray = array(array(1,2,1), array(2,1,1));
        $this->object->gameState = BMGameState::endRound;
        $this->object->do_next_step();
        $this->assertFalse(isset($this->object->activePlayerIdx));
        $this->assertFalse(isset($this->object->playerWithInitiativeIdx));
        $this->assertFalse(isset($this->object->activeDieArrayArray));
        $this->assertEquals(array(array(), array()), $this->object->capturedDieArrayArray);
        $this->assertEquals(array(FALSE, FALSE), $this->object->passStatusArray);
        $this->assertFalse(isset($this->object->roundScoreArray));
        $this->assertEquals(array(array('W' => 1, 'L' => 3, 'D' => 1),
                                  array('W' => 3, 'L' => 1, 'D' => 1)),
                            $this->object->gameScoreArrayArray);
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_end_game() {
        $this->object->gameState = BMGameState::endGame;
        $this->object->activePlayerIdx = 1;
        $this->object->do_next_step();
        $this->assertFalse(isset($this->object->activePlayerIdx));
    }

    /**
     * @covers BMGame::do_next_step
     */
    public function test_do_next_step_undefined() {
        unset($this->object->gameState);
        try {
            $this->object->do_next_step();
            fail('Game state must be set.');
        }
        catch (LogicException $expected) {
        }
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_start_game() {
        $this->object->gameState = BMGameState::startGame;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::startGame, $this->object->gameState);

        // default unspecified playerIdArray
        $this->object->gameState = BMGameState::startGame;
        $Button1 = new BMButton;
        $Button2 = new BMButton;
        $this->object->buttonArray = array($Button1, $Button2);
        $this->object->maxWins = 3;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::startGame, $this->object->gameState);

        $this->object->gameState = BMGameState::startGame;
        $this->object->playerIdArray = array(12345, 54321);
        $Button1 = new BMButton;
        $Button2 = new BMButton;
        $this->object->buttonArray = array($Button1, $Button2);
        $this->object->maxWins = 3;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::applyHandicaps, $this->object->gameState);
        $this->assertEquals(array(FALSE, FALSE), $this->object->passStatusArray);
        $this->assertEquals(array(array(0, 0, 0), array(0, 0, 0)),
                            $this->object->gameScoreArrayArray);
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_apply_handicaps() {
        $this->object->gameState = BMGameState::applyHandicaps;
        unset($this->object->maxWins);
        try {
            $this->object->update_game_state();
            fail('Max wins must exist.');
        }
        catch (LogicException $expected) {
        }

        $this->object->playerIdArray = array(12345, 54321);
        $this->object->gameState = BMGameState::applyHandicaps;
        $this->object->maxWins = 3;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::applyHandicaps,
                            $this->object->gameState);

        $this->object->playerIdArray = array('12345', '54321');
        $this->object->gameState = BMGameState::applyHandicaps;
        $this->object->gameScoreArrayArray = array(array(0, 0, 0),array(0, 0, 0));
        $this->object->maxWins = 3;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::chooseAuxiliaryDice,
                            $this->object->gameState);

        $this->object->playerIdArray = array('12345', '54321');
        $this->object->gameState = BMGameState::applyHandicaps;
        $this->object->gameScoreArrayArray = array(array(3, 0, 0),array(0, 3, 0));
        $this->object->maxWins = 3;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::endGame, $this->object->gameState);
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_choose_auxiliary_dice() {
        $this->object->gameState = BMGameState::chooseAuxiliaryDice;
        $button1 = new BMButton;
        $button1->recipe = '(4) (8) (12) (20)';
        if (isset($button1->dieArray)) {
            unset($button1->dieArray);
        }
        $button2 = new BMButton;
        $button2->recipe = '(4) (4) (4) (20)';
        if (isset($button2->dieArray)) {
            unset($button2->dieArray);
        }

        $this->object->buttonArray = array($button1, $button2);
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::loadDiceIntoButtons, $this->object->gameState);

        $button3 = new BMButton;
        $button3->recipe = '(4) (4) (8) +(20)';
        if (isset($button3->dieArray)) {
            unset($button3->dieArray);
        }

        $this->object->gameState = BMGameState::chooseAuxiliaryDice;
        $this->object->buttonArray = array($button1, $button3);
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::chooseAuxiliaryDice,
                            $this->object->gameState);
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_load_dice_into_buttons() {
        $this->object->gameState = BMGameState::loadDiceIntoButtons;
        $button1 = new BMButton;
        $button2 = new BMButton;
        $button1->load('(4) (8) (12) (20)');
        $button2->load('(4) (12) (20) (X)');
        $this->object->buttonArray = array($button1, new $button2);
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::loadDiceIntoButtons, $this->object->gameState);

        $this->object->gameState = BMGameState::loadDiceIntoButtons;
        $button1 = new BMButton;
        $button2 = new BMButton;
        $button1->load('(4) (8) (12) (20)');
        $button2->load('(4) (12) (20) (X)');
        $this->object->buttonArray = array($button1, $button2);
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::addAvailableDiceToGame, $this->object->gameState);
    }

    public function test_update_game_state_add_available_dice_to_game() {
        $this->object->gameState = BMGameState::addAvailableDiceToGame;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::addAvailableDiceToGame,
                            $this->object->gameState);

        $this->object->gameState = BMGameState::addAvailableDiceToGame;
        $die1 = new BMDie;
        $die2 = new BMDie;
        $die3 = new BMDie;
        $die4 = new BMDie;
        $this->object->activeDieArrayArray = array(array($die1, $die2),
                                                   array($die3, $die4));
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::specifyDice, $this->object->gameState);
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_specify_dice() {
        $this->object->gameState = BMGameState::specifyDice;
        $button1 = new BMButton;
        $button2 = new BMButton;
        $button1->load('(4) (8) (12) (20)');
        $button2->load('(4) (12) (20) (20)');
        $this->object->activeDieArrayArray = array($button1->dieArray,
                                                   $button2->dieArray);
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::determineInitiative,
                            $this->object->gameState);

        $this->object->gameState = BMGameState::specifyDice;
        $button1 = new BMButton;
        $button2 = new BMButton;
        $button1->load('(4) (8) (12) (20)');
        $button2->load('(4) (12) (20) (X)');
        $this->object->activeDieArrayArray = array($button1->dieArray,
                                                   $button2->dieArray);
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::specifyDice, $this->object->gameState);

        //james: option dice are not yet implemented
//        $this->object->gameState = BMGameState::specifyDice;
//        $button1 = new BMButton;
//        $button2 = new BMButton;
//        $button1->load_from_recipe('(4) (8) (12) (20)');
//        $button2->load_from_recipe('(4) (12) (20) (4/12)');
//        var_dump($button2);
//        $this->object->buttonArray = array($button1, $button2);
//        $this->object->update_game_state();
//        $this->assertEquals(BMGameState::specifyDice, $this->object->gameState);
    }


    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_determine_initiative() {
        $this->object->gameState = BMGameState::determineInitiative;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::determineInitiative,
                            $this->object->gameState);

        $this->object->gameState = BMGameState::determineInitiative;
        $this->object->playerWithInitiativeIdx = 0;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::startRound, $this->object->gameState);
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_start_round() {
        $this->object->gameState = BMGameState::startRound;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::startRound, $this->object->gameState);

        $this->object->gameState = BMGameState::startRound;
        $this->object->activePlayerIdx = 0;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::startTurn, $this->object->gameState);
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_start_turn() {
        $this->object->gameState = BMGameState::startTurn;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::startTurn, $this->object->gameState);

        $this->object->gameState = BMGameState::startTurn;
        $this->object->attack = array(0, 1, array(), array(), 'pass');
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::endTurn, $this->object->gameState);
        //james: need to check that the attack has been carried out
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_end_turn() {
        $die1 = new BMDie;
        $die2 = new BMDie;

        // both players still have dice and both have not passed
        $this->object->playerIdArray = array(12345, 54321);
        $this->object->activeDieArrayArray = array(array($die1),
                                                   array($die2));
        $this->object->passStatusArray = array(FALSE, FALSE);
        $this->object->gameState = BMGameState::endTurn;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::startTurn, $this->object->gameState);
        $this->assertTrue(isset($this->object->activeDieArrayArray));
        $this->assertEquals(array(FALSE, FALSE), $this->object->passStatusArray);

        $this->object->playerIdArray = array(12345, 54321);
        $this->object->activeDieArrayArray = array(array($die1),
                                                   array($die2));
        $this->object->passStatusArray = array(TRUE, FALSE);
        $this->object->gameState = BMGameState::endTurn;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::startTurn, $this->object->gameState);
        $this->assertTrue(isset($this->object->activeDieArrayArray));
        $this->assertEquals(array(TRUE, FALSE), $this->object->passStatusArray);

        $this->object->playerIdArray = array(12345, 54321);
        $this->object->activeDieArrayArray = array(array($die1),
                                                   array($die2));
        $this->object->passStatusArray = array(FALSE, TRUE);
        $this->object->gameState = BMGameState::endTurn;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::startTurn, $this->object->gameState);
        $this->assertTrue(isset($this->object->activeDieArrayArray));
        $this->assertEquals(array(FALSE, TRUE), $this->object->passStatusArray);

        // both players have passed
        $this->object->activeDieArrayArray = array(array($die1),
                                                   array($die2));
        $this->object->passStatusArray = array(TRUE, TRUE);
        $this->object->gameState = BMGameState::endTurn;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::endRound, $this->object->gameState);

        // the first player has no dice
        $this->object->activeDieArrayArray = array(array($die1),
                                                   array());
        $this->object->passStatusArray = array(FALSE, FALSE);
        $this->object->gameState = BMGameState::endTurn;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::endRound, $this->object->gameState);

        // the second player has no dice
        $this->object->activeDieArrayArray = array(array(),
                                                   array($die2));
        $this->object->passStatusArray = array(FALSE, FALSE);
        $this->object->gameState = BMGameState::endTurn;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::endRound, $this->object->gameState);
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_end_round() {
        $this->object->gameState = BMGameState::endRound;
        $this->object->gameScoreArrayArray = array(array(2,1,2), array(1,2,2));
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::loadDiceIntoButtons, $this->object->gameState);

        $this->object->activePlayerIdx = 0;
        $this->object->gameState = BMGameState::endRound;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::endRound, $this->object->gameState);

        unset($this->object->activePlayerIdx);
        $this->object->maxWins = 5;
        $this->object->gameScoreArrayArray = array(array(5,2,1),
                                                   array(2,5,1));
        $this->object->gameState = BMGameState::endRound;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::endGame, $this->object->gameState);
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_end_game() {
        $this->object->gameState = BMGameState::endGame;
        $this->object->update_game_state();
        $this->assertEquals(BMGameState::endGame, $this->object->gameState);
    }

    /**
     * @covers BMGame::update_game_state
     */
    public function test_update_game_state_not_set() {
        unset($this->object->gameState);
        try {
            $this->object->update_game_state();
            $this->fail('An undefined game state cannot be updated.');
        }
        catch (LogicException $expected) {
        }
    }

    /**
     * @covers BMGame::proceed_to_next_user_action
     */
    public function test_proceed_to_next_user_action() {
        $this->object->gameState = BMGameState::endGame;
        $this->object->proceed_to_next_user_action();
        $this->assertEquals(BMGameState::endGame, $this->object->gameState);

        // james: need to complete this
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
                'This test has not been implemented yet.'
        );
    }

    /**
     * @covers BMGame::add_die
     */
    public function test_add_die() {
        $die1 = new BMDie;
        try {
            $this->object->add_die($die1);
            $this->fail('activeDieArrayArray must be set before a die can be added.');
        }
        catch (LogicException $expected) {
        }

        $this->object->activeDieArrayArray = array(array(), array());
        $die2 = new BMDie;
        $die2->ownerObject = $this->object;
        $die2->playerIdx = 1;
        $this->object->add_die($die2);
        $this->assertEquals(1, count($this->object->activeDieArrayArray[1]));
        $this->assertEquals($die2, $this->object->activeDieArrayArray[1][0]); // clone

        $die3 = new BMDie;
        $die3->ownerObject = $this->object;
        $die3->playerIdx = 1;
        $this->object->add_die($die3);
        $this->assertEquals(2, count($this->object->activeDieArrayArray[1]));
        $this->assertEquals($die2, $this->object->activeDieArrayArray[1][0]); // clone
        $this->assertEquals($die3, $this->object->activeDieArrayArray[1][1]); // clone
    }

    /**
     * @covers BMGame::capture_die
     */
    public function test_capture_die() {
        try {
            $this->object->capture_die(new BMDie);
            $this->fail('activeDieArrayArray must be set before capturing dice.');
        }
        catch (LogicException $expected) {
        }

        // valid capture
        $die = new BMDie;
        $this->object->activeDieArrayArray = array(array(new BMDie), array($die));
        $this->object->capture_die($die);

        // invalid capture
        $this->object->activeDieArrayArray = array(array(new BMDie), array(new BMDie));
        try {
            $this->object->capture_die(new BMDie);
            $this->fail('Captured die does not exist for the defender.');
        }
        catch (LogicException $expected) {
        }


    }

    /**
     * @covers BMGame::request_swing_values
     */
    public function test_request_swing_values() {
        $this->assertFalse(isset($this->object->swingRequestArrayArray));

        $die = new BMDieSwing;
        $swingtype = 'X';
        $playerIdx = 1;

        $this->object->request_swing_values($die, $swingtype, $playerIdx);
        $this->assertEquals(array(array(), array('X' => array($die))),
                            $this->object->swingRequestArrayArray);
    }

    /**
     * @covers BMGame::does_recipe_have_auxiliary_dice
     */
    public function test_does_recipe_have_auxiliary_dice() {
        $this->assertFalse(BMGame::does_recipe_have_auxiliary_dice('(4) (8) (12) (20)'));

        $this->assertTrue(BMGame::does_recipe_have_auxiliary_dice('(4) (8) (12) +(20)'));
    }

    /**
     * @covers BMGame::separate_out_auxiliary_dice
     */
    public function test_separate_out_auxiliary_dice() {
        $recipe = '(4) (12) (16) (20)';
        $this->assertEquals(array($recipe, ''),
                            BMGame::separate_out_auxiliary_dice($recipe));

        $recipe = '(4) +(12) (16) (20)+';
        $this->assertEquals(array('(4) (16)', '(12) (20)'),
                            BMGame::separate_out_auxiliary_dice($recipe));
    }

    /**
     * @covers BMGame::is_die_specified
     */
    public function test_is_die_specified() {
        // unspecified die
        $die = new BMDie;
        $this->assertFalse(BMGame::is_die_specified($die));

        // normal die
        $die = BMDie::create(12);
        $this->assertTrue(BMGame::is_die_specified($die));

//        // swing die
//        $die = new BMDie;
//        $die->mSides = 'X';
//        $die->mSkills = '';
//        $this->assertFalse(BMGame::is_die_specified($die));
//
//        // option die
//        $die = new BMDie;
//        $die->mSides = '8/12';
//        $die->mSkills = '';
//        $this->assertFalse(BMGame::is_die_specified($die));
    }

    /**
     * @covers BMGame::is_valid_attack
     */
    public function test_is_valid_attack() {
        $method = new ReflectionMethod('BMGame', 'is_valid_attack');
        $method->setAccessible(TRUE);

        // check when there is no attack set
        $this->assertFalse($method->invoke($this->object));

        // check with a pass attack
        $this->object->attack = array(0, 1, array(), array(), 'pass');
        $this->assertTrue($method->invoke($this->object));

        // james: need to add test cases for invalid attacks
    }

    /**
     * @covers BMGame::reset_play_state
     */
    public function test_reset_game_state() {
        $method = new ReflectionMethod('BMGame', 'reset_play_state');
        $method->setAccessible(TRUE);

        $this->object->playerIdArray = array(12345, 54321);
        $this->object->activePlayerIdx = 1;
        $this->object->playerWithInitiativeIdx = 0;

        $die1 = BMDie::create(3);
        $die2 = BMDie::create(4);
        $BMDie3 = BMDie::create(5);
        $BMDie4 = BMDie::create(6);

        $this->object->activeDieArrayArray = array(array($die1), array($die2));
        $this->object->passStatusArray = array(TRUE, TRUE);
        $this->object->capturedDieArrayArray = array(array($BMDie3), array($BMDie4));
//        $this->object->roundScoreArray = array(40, -25);
        $this->object->waitingOnActionArray = array(FALSE, TRUE);

        $method->invoke($this->object);
        $this->assertFalse(isset($this->object->activePlayerIdx));
        $this->assertFalse(isset($this->object->playerWithInitiativeIdx));
        $this->assertFalse(isset($this->object->activeDieArrayArray));
        $this->assertEquals(array(FALSE, FALSE), $this->object->passStatusArray);
        $this->assertEquals(array(array(), array()), $this->object->capturedDieArrayArray);
        $this->assertFalse(isset($this->object->roundScoreArray));
        $this->assertEquals(array(FALSE, FALSE), $this->object->waitingOnActionArray);
    }

    /**
     * @covers BMGame::update_active_player
     */
    public function test_update_active_player() {
        $method = new ReflectionMethod('BMGame', 'update_active_player');
        $method->setAccessible(TRUE);

        $game = new BMGame(1234,
                           array(1, 12, 21, 3, 15),
                           array('', '', '', '', ''),
                           3);
        $game->activePlayerIdx = 0;
        $method->invoke($game);
        $this->assertEquals(1, $game->activePlayerIdx);
        $method->invoke($game);
        $this->assertEquals(2, $game->activePlayerIdx);
        $method->invoke($game);
        $this->assertEquals(3, $game->activePlayerIdx);
        $method->invoke($game);
        $this->assertEquals(4, $game->activePlayerIdx);
        $method->invoke($game);
        $this->assertEquals(0, $game->activePlayerIdx);
    }

    /**
     * @covers BMGame::__construct
     * @covers BMGame::__get
     */
    public function test__construct() {
        // construct default empty game
        $game = new BMGame;
        $this->assertEquals(0, $game->gameId);
        $this->assertEquals(array(0, 0), $game->playerIdArray);
        $this->assertEquals(2, $game->nPlayers);
        $this->assertEquals(BMGameState::startGame, $game->gameState);
        $this->assertNull($game->buttonArray[0]);
        $this->assertNull($game->buttonArray[1]);
        $this->assertEquals(3, $game->maxWins);
        // the gameScoreArrayArray must remain unset until BMGameState::applyHandicaps
        $this->assertTrue(!isset($this->object->gameScoreArrayArray));
        $this->assertEquals(array(FALSE, FALSE), $game->waitingOnActionArray);
        $this->assertEquals(array(FALSE, FALSE), $game->isPrevRoundWinnerArray);

        // construct valid game
        $gameId = 2745;
        $playerIdArray = array(123, 456);
        $buttonRecipeArray = array('(4) (8) (12) (20)', '(4) (4) (4) (20)');
        $maxWins = 5;
        $game = new BMGame($gameId, $playerIdArray, $buttonRecipeArray, $maxWins);
        $this->assertEquals($playerIdArray, $game->playerIdArray);
        $this->assertEquals(2, $game->nPlayers);
        $this->assertEquals($buttonRecipeArray[0], $game->buttonArray[0]->recipe);
        $this->assertEquals($buttonRecipeArray[1], $game->buttonArray[1]->recipe);
        $this->assertEquals($maxWins, $game->maxWins);
        $this->assertEquals(array(FALSE, FALSE), $game->waitingOnActionArray);

        // construct invalid game
        $gameId = 2745;
        $playerIdArray = array(123, 456, 789);
        $buttonRecipeArray = array('(4) (8) (12) (20)', '(4) (4) (4) (20)');
        $maxWins = 5;
        try {
            $game = new BMGame($gameId, $playerIdArray, $buttonRecipeArray, $maxWins);
            $this->fail('The number of buttons must equal the number of players.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__get
     */
    public function test__get_attacker_player_idx() {
        $this->assertNull($this->object->attackerPlayerIdx);

        $this->object->attack = array(1, 0, array(), array(), 'pass');
        $this->assertEquals(1, $this->object->attackerPlayerIdx);
    }

    /**
     * @covers BMGame::__get
     */
    public function test__get_defender_player_idx() {
        $this->assertNull($this->object->defenderPlayerIdx);

        $this->object->attack = array(1, 0, array(), array(), 'pass');
        $this->assertEquals(0, $this->object->defenderPlayerIdx);
    }

    /**
     * @covers BMGame::__get
     */
    public function test__get_attacker_all_die_array() {
        $this->assertNull($this->object->attackerAllDieArray);

        $die1 = new BMDie;
        $die2 = new BMDie;
        $die3 = new BMDie;
        $die4 = new BMDie;
        $this->object->activeDieArrayArray = array(array($die1, $die2),
                                                   array($die3, $die4));
        $this->object->attack = array(1, 0, array(), array(), 'pass');
        $this->assertEquals(array($die3, $die4), $this->object->attackerAllDieArray);
    }

    /**
     * @covers BMGame::__get
     */
    public function test__get_defender_all_die_array() {
        $this->assertNull($this->object->defenderAllDieArray);

        $die1 = new BMDie;
        $die2 = new BMDie;
        $die3 = new BMDie;
        $die4 = new BMDie;
        $this->object->activeDieArrayArray = array(array($die1, $die2),
                                                   array($die3, $die4));
        $this->object->attack = array(1, 0, array(), array(), 'pass');
        $this->assertEquals(array($die1, $die2), $this->object->defenderAllDieArray);
    }

    /**
     * @covers BMGame::__get
     */
    public function test__get_attacker_attack_die_array() {
        $this->assertEquals(NULL, $this->object->attackerAttackDieArray);

        $this->object->activeDieArrayArray = array(array(), array());
        $this->object->attack = array(0, 1, array(), array(), 'pass');
        $this->assertEquals(array(), $this->object->attackerAttackDieArray);

        $die1 = new BMDie;
        $die2 = new BMDie;
        $die3 = new BMDie;
        $die4 = new BMDie;

        $this->object->activeDieArrayArray = array(array($die1, $die2),
                                                   array($die3, $die4));
        $this->object->attack = array(1, 0, array(1), array(0), 'power');
        $this->assertEquals(array($die4), $this->object->attackerAttackDieArray);
    }

    /**
     * @covers BMGame::__get
     */
    public function test__get_defender_attack_die_array() {
        $this->assertEquals(NULL, $this->object->defenderAttackDieArray);

        $this->object->attack = array(0, 1, array(), array(), 'pass');
        $this->assertEquals(array(), $this->object->defenderAttackDieArray);

        $die1 = new BMDie;
        $die2 = new BMDie;
        $die3 = new BMDie;
        $die4 = new BMDie;

        $this->object->activeDieArrayArray = array(array($die1, $die2),
                                                   array($die3, $die4));
        $this->object->attack = array(1, 0, array(1), array(0), 'power');
        $this->assertEquals(array($die2), $this->object->defenderAttackDieArray);
    }

    /**
     * @covers BMGame::__get
     */
    public function test__get_round_score_array() {
        $die1 = BMDie::create(5);
        $die2 = BMDie::create(8);

        $die1->captured = FALSE;
        $this->object->activeDieArrayArray = array(array($die1), array());
        $this->object->capturedDieArrayArray = array(array(), array());
        $this->assertEquals(array(5/2, 0), $this->object->roundScoreArray);

        $die1->captured = FALSE;
        $die2->captured = FALSE;
        $this->object->activeDieArrayArray = array(array(), array($die1, $die2));
        $this->object->capturedDieArrayArray = array(array(), array());
        $this->assertEquals(array(0, 13/2), $this->object->roundScoreArray);

        $die1->captured = TRUE;
        $this->object->activeDieArrayArray = array(array(), array());
        $this->object->capturedDieArrayArray = array(array(), array($die1));
        $this->assertEquals(array(0, 5), $this->object->roundScoreArray);

        $die1->captured = TRUE;
        $die2->captured = TRUE;
        $this->object->activeDieArrayArray = array(array(), array());
        $this->object->capturedDieArrayArray = array(array(), array($die1, $die2));
        $this->assertEquals(array(0, 13), $this->object->roundScoreArray);
    }

    /**
     * @covers BMGame::__get
     */
    public function test__get_nonexistent() {
        // check that a nonexistent property can be gotten gracefully
        $this->assertEquals(NULL, $this->object->nonsenseVariable);

        $button1 = new BMButton;
        $button2 = new BMButton;
        $this->object->buttonArray = array($button1, $button2);
        $this->assertEquals(array($button1, $button2), $this->object->buttonArray);
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_nPlayers() {
        // set is always invalid
        try {
            $this->object->nPlayers = 5;
            $this->fail('The number of players is automatically determined.');
        }
        catch (LogicException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_game_id() {
        // valid set
        $this->object->gameId = 235;

        // invalid set
        try {
            $this->object->gameId = 'abc';
            $this->fail('The game ID must be a non-negative integer.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_player_idx_array() {
        $game = new BMGame(12345, array(123, 456), array('', ''), 3);

        // valid set
        $game->playerIdArray = array(345, 567);

        // invalid set
        try {
            $game->playerIdArray = array(123, 345, 567);
            $this->fail('The number of players cannot change during a game.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_active_player_idx() {
        $game = new BMGame(12345, array(123, 456), array('', ''), 3);

        // valid set
        $game->activePlayerIdx = 0;

        // invalid set
        try {
            $game->activePlayerIdx = 6;
            $this->fail('The active player index must be a valid index.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_player_with_initiative_idx() {
        $game = new BMGame(12345, array(123, 456), array('', ''), 3);

        // valid set
        $game->playerWithInitiativeIdx = 0;

        // invalid set
        try {
            $game->playerWithInitiativeIdx = 6;
            $this->fail('The index of the player with initiative must be valid.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }


    /**
     * @covers BMGame::__set
     */
    public function test__set_button_array() {
        $game = new BMGame(12345, array(123, 456), array('', ''), 3);

        $button1 = new BMButton;
        $button2 = new BMButton;
        $button3 = new BMButton;

        $button1->load('p(23)');
        $button2->load('s(58)');
        $button3->load('(4) (8)');

        // valid set
        $game->buttonArray = array($button1, $button2);
        $this->assertEquals(0, $button1->playerIdx);
        $this->assertEquals(1, $button2->playerIdx);

        // invalid set
        try {
            $game->buttonArray = array($button1, $button2, $button3);
            $this->fail('The number of buttons must match the number of players.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $game->buttonArray = array('(45)', '(23)');
            $this->fail('The buttonArray must contain BMButtons.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_game_score_array_array() {
        $this->object->playerIdArray = array(12345, 54321);
        $die1 = new BMDie;
        $die2 = new BMDie;
        $this->object->dieArrayArray = array(array($die1), array($die2));
        $this->assertEquals($die1, $this->object->dieArrayArray[0][0]);
        $this->assertEquals($die2, $this->object->dieArrayArray[1][0]);

        $this->object->gameScoreArrayArray = array(array(2,1,1), array(1,2,1));

        try {
            $this->object->gameScoreArrayArray = array(array(2,1,1), array(1,2));
            $this->fail('W/L/D must be three numbers.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->gameScoreArrayArray = array(array(2,1,1));
            $this->fail('There must be the same number of players and game scores.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_active_die_array_array() {
        $die1 = new BMDie;
        $die2 = new BMDie;

        // valid set
        $this->object->activeDieArrayArray = array(array(), array());
        $this->object->activeDieArrayArray = array(array($die1), array($die2));

        // invalid set
        try {
            $this->object->activeDieArrayArray = 'abc';
            $this->fail('Active die array array must be an array.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->activeDieArrayArray = array(1, 2);
            $this->fail('Active die arrays must be arrays.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->activeDieArrayArray = array(array(1), array(2));
            $this->fail('Active die arrays must be arrays of BM dice.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_attack() {
        try {
            $this->object->attack = array(array(1), array(2));
            $this->fail('There must be exactly five elements in attack.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->attack = array(array(1), 2, array(array(1,3)), array(array(2,5)), '');
            $this->fail('The first element of attack must be an integer.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->attack = array(1, array(2), array(array(1,3)), array(array(2,5)), '');
            $this->fail('The second element of attack must be an integer.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->attack = array(1, 2, 1, array(array(1,3)), '');
            $this->fail('The third element of attack must be an array.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->attack = array(1, 2, array(array(1,3)), 12, '');
            $this->fail('The fourth element of attack must be an array.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->attack = array(1, 2, array(array(1,3)), 12, '');
            $this->fail('The third element of attack must be a 1-D array of indices.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->attack = array(1, 2, array(array(1,3)), 12, '');
            $this->fail('The third element of attack must be a 1-D array of indices.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->attack = array(1, 2, array('hello'), array(0), '');
            $this->fail('The third element of attack must be a 1-D array of indices.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->attack = array(1, 2, array(0), array('hello'), '');
            $this->fail('The fourth element of attack must be a 1-D array of indices.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->attack = array(1, 2, array(1), array(0), 'xxyyzz');
            $this->fail('The fifth element of attack must be a valid string.');
        }
        catch (InvalidArgumentException $expected) {
        }

        // check that attacker die indices are validated
        $this->object->activeDieArrayArray =
            array(array(new BMDie), array(new BMDie));
        try {
            $this->object->attack = array(0, 1, array(2), array(0), 'pass');
            $this->fail('Invalid attacker die indices.');
        }
        catch (LogicException $expected) {
        }

        // check that defender die indices are validated
        $this->object->activeDieArrayArray =
            array(array(new BMDie), array(new BMDie));
        try {
            $this->object->attack = array(0, 1, array(0), array(2), 'pass');
            $this->fail('Invalid defender die indices.');
        }
        catch (LogicException $expected) {
        }

        // check that a pass attack is valid
        $this->object->attack = array(0, 1, array(), array(), 'pass');

        // check that a skill attack is valid
        $this->object->activeDieArrayArray =
            array(array(new BMDie, new BMDie), array(new BMDie));
        $this->object->attack = array(0, 1, array(0, 1), array(0), 'skill');

        // check that an invalid attack is invalid
        try {
            $this->object->attack = array(1, 2, array(0, 1), 0, 'xxyyzz');
            $this->fail('Invalid attack type.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_attacker_attack_die_array() {
        try {
            $this->object->attackerAttackDieArray = array();
            $this->fail('AttackerAttackDieArray cannot be set.');
        }
        catch (LogicException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_defender_attack_die_array() {
        try {
            $this->object->defenderAttackDieArray = array();
            $this->fail('DefenderAttackDieArray cannot be set.');
        }
        catch (LogicException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_pass_status_array() {
        // valid set
        $this->object->passStatusArray = array(TRUE, FALSE);

        // invalid set
        try {
            $this->object->passStatusArray = TRUE;
            $this->fail('Pass status array must be an array.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->passStatusArray = array(TRUE, TRUE, TRUE);
            $this->fail('Pass status array must have the same number of elements '.
                        'as the number of players.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->passStatusArray = array(1, 2);
            $this->fail('Pass statuses must be booleans.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_captured_die_array_array() {
        $die1 = new BMDie;
        $die2 = new BMDie;

        // valid set
        $this->object->capturedDieArrayArray = array(array(), array());
        $this->object->capturedDieArrayArray = array(array($die1), array($die2));

        // invalid set
        try {
            $this->object->capturedDieArrayArray = 'abc';
            $this->fail('Active die array array must be an array.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->capturedDieArrayArray = array(1, 2);
            $this->fail('Active die arrays must be arrays.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->capturedDieArrayArray = array(array(1), array(2));
            $this->fail('Active die arrays must be arrays of BM dice.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_round_score_array() {
        // all sets are invalid
        try {
            $this->object->roundScoreArray = array(22, 35);
            $this->fail('Round score array cannot be set directly.');
        }
        catch (LogicException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_max_wins() {
        // valid set
        $this->object->maxWins = 5;

        // invalid set
        try {
            $this->object->maxWins = 0;
            $this->fail('maxWins must be a positive integer.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->maxWins = 2.5;
            $this->fail('maxWins must be a positive integer.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_game_state() {
        // valid set
        $this->object->gameState = BMGameState::startRound;

        // invalid set
        try {
            $this->object->gameState = 'abcd';
            $this->fail('Game state must be an integer.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $this->object->gameState = 0;
            $this->fail('Invalid game state.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__set
     */
    public function test__set_waiting_on_action_array() {
        $game = new BMGame(12345, array(123, 456), array('', ''), 3);

        // valid set
        $game->waitingOnActionArray = array(TRUE, FALSE);

        // invalid set
        try {
            $game->waitingOnActionArray = array(TRUE, FALSE, FALSE);
            $this->fail('The action array must match the number of players.');
        }
        catch (InvalidArgumentException $expected) {
        }

        try {
            $game->waitingOnActionArray = array(1, 2);
            $this->fail('The action array must contain booleans.');
        }
        catch (InvalidArgumentException $expected) {
        }
    }

    /**
     * @covers BMGame::__isset
     */
    public function test__isset() {
        $button1 = new BMButton;
        $button2 = new BMButton;
        $this->object->buttonArray = array($button1, $button2);
        $this->assertTrue(isset($this->object->buttonArray));
    }

    /**
     * @covers BMGame::__unset
     */
    public function test__unset() {
        // check that a nonexistent property can be unset gracefully
        unset($this->object->rubbishVariable);

        $button1 = new BMButton;
        $button2 = new BMButton;
        $this->object->buttonArray = array($button1, $button2);
        unset($this->object->buttonArray);
        $this->assertFalse(isset($this->object->buttonArray));
    }


    /**
     * @covers BMGame::getJsonData
     */
    public function test__get_json_data() {
        $button1 = new BMButton;
        $button1->load('(8) (10) (12) (20) (X)', 'Bauer');

        $button2 = new BMButton;
        $button2->load('(4) (6) (8) (X) (X)', 'Stark');

        // load game
        $game = new BMGame(424242, array(123, 456));
        $game->buttonArray = array($button1, $button2);
        $game->waitingOnActionArray = array(FALSE, FALSE);
        $game->proceed_to_next_user_action();

        $out = $game->getJsonData();

//        var_dump($out);

    }

    /**
     * @coversNothing
     */
    public function test_full_soldiers_game() {
        // load buttons
        $button1 = new BMButton;
        $button1->load('(8) (10) (12) (20) (X)', 'Bauer');
        $this->assertEquals('Bauer', $button1->name);
        $this->assertEquals('(8) (10) (12) (20) (X)', $button1->recipe);
        // check dice in $button1->dieArray are correct
        $this->assertEquals(5, count($button1->dieArray));
        $this->assertEquals(8, $button1->dieArray[0]->max);
        $this->assertEquals(10, $button1->dieArray[1]->max);
        $this->assertEquals(12, $button1->dieArray[2]->max);
        $this->assertEquals(20, $button1->dieArray[3]->max);
        $this->assertFalse(isset($button1->dieArray[4]->max));
        $this->assertTrue($button1->dieArray[4] instanceof BMDieSwing);
        $this->assertTrue($button1->dieArray[4]->needsValue);

        $button2 = new BMButton;
        $button2->load('(4) (6) (8) (X) (X)', 'Stark');
        $this->assertEquals('Stark', $button2->name);
        $this->assertEquals('(4) (6) (8) (X) (X)', $button2->recipe);
        $this->assertEquals(5, count($button1->dieArray));
        $this->assertEquals(4, $button2->dieArray[0]->max);
        $this->assertEquals(6, $button2->dieArray[1]->max);
        $this->assertEquals(8, $button2->dieArray[2]->max);
        $this->assertFalse(isset($button2->dieArray[3]->max));
        $this->assertFalse(isset($button2->dieArray[4]->max));
        $this->assertTrue($button2->dieArray[3] instanceof BMDieSwing);
        $this->assertTrue($button2->dieArray[4] instanceof BMDieSwing);
        $this->assertTrue($button2->dieArray[3]->needsValue);
        $this->assertTrue($button2->dieArray[4]->needsValue);

        // load game
        $game = new BMGame(424242, array(123, 456));
        $this->assertEquals(BMGameState::startGame, $game->gameState);
        $game->proceed_to_next_user_action();
        $this->assertEquals(BMGameState::startGame, $game->gameState);

        $game->buttonArray = array($button1, $button2);
        $this->assertEquals($game, $game->buttonArray[0]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[1]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[0]->dieArray[0]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[0]->dieArray[1]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[0]->dieArray[2]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[0]->dieArray[3]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[0]->dieArray[4]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[1]->dieArray[0]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[1]->dieArray[1]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[1]->dieArray[2]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[1]->dieArray[3]->ownerObject);
        $this->assertEquals($game, $game->buttonArray[1]->dieArray[4]->ownerObject);

        $game->waitingOnActionArray = array(FALSE, FALSE);
        $game->proceed_to_next_user_action();
        $this->assertEquals(array(array(), array()), $game->capturedDieArrayArray);
        $this->assertEquals(array(TRUE, TRUE), $game->waitingOnActionArray);
        $this->assertEquals(BMGameState::specifyDice, $game->gameState);
        $this->assertEquals(array(array('X'=>NULL), array('X'=>NULL)),
                            $game->swingValueArrayArray);

        // specify swing dice incorrectly
        $game->swingValueArrayArray = array(array('X'=>3), array('X'=>4));
        $game->proceed_to_next_user_action();
        $this->assertEquals(array(TRUE, FALSE), $game->waitingOnActionArray);
        $this->assertEquals(BMGameState::specifyDice, $game->gameState);
        $this->assertEquals(array(array(), array('X'=>4)),
                            $game->swingValueArrayArray);

        // specify swing dice correctly
        $game->swingValueArrayArray = array(array('X'=>19), array('X'=>4));
        $game->proceed_to_next_user_action();
        $this->assertTrue($game->activeDieArrayArray[0][4] instanceof BMDieSwing);
        $this->assertTrue($game->activeDieArrayArray[1][3] instanceof BMDieSwing);
        $this->assertTrue($game->activeDieArrayArray[1][4] instanceof BMDieSwing);
        $this->assertFalse($game->activeDieArrayArray[0][4]->needsValue);
        $this->assertFalse($game->activeDieArrayArray[1][3]->needsValue);
        $this->assertFalse($game->activeDieArrayArray[1][4]->needsValue);

        $this->assertEquals(1, array_sum($game->waitingOnActionArray));
        $this->assertEquals(BMGameState::startTurn, $game->gameState);
        $this->assertEquals(array(array('X'=>19), array('X'=>4)),
                            $game->swingValueArrayArray);
        $this->assertEquals(8,  $game->activeDieArrayArray[0][0]->max);
        $this->assertEquals(10, $game->activeDieArrayArray[0][1]->max);
        $this->assertEquals(12, $game->activeDieArrayArray[0][2]->max);
        $this->assertEquals(20, $game->activeDieArrayArray[0][3]->max);
        $this->assertEquals(19, $game->activeDieArrayArray[0][4]->max);
        $this->assertEquals(4,  $game->activeDieArrayArray[1][0]->max);
        $this->assertEquals(6,  $game->activeDieArrayArray[1][1]->max);
        $this->assertEquals(8,  $game->activeDieArrayArray[1][2]->max);
        $this->assertEquals(4,  $game->activeDieArrayArray[1][3]->max);
        $this->assertEquals(4,  $game->activeDieArrayArray[1][4]->max);
        $this->assertEquals(19, $game->activeDieArrayArray[0][4]->swingValue);
        $this->assertEquals(4,  $game->activeDieArrayArray[1][3]->swingValue);
        $this->assertEquals(4,  $game->activeDieArrayArray[1][4]->swingValue);

        $this->assertNotNull($game->activeDieArrayArray[0][0]->value);
        $this->assertNotNull($game->activeDieArrayArray[0][1]->value);
        $this->assertNotNull($game->activeDieArrayArray[0][2]->value);
        $this->assertNotNull($game->activeDieArrayArray[0][3]->value);
        $this->assertNotNull($game->activeDieArrayArray[0][4]->value);
        $this->assertNotNull($game->activeDieArrayArray[1][0]->value);
        $this->assertNotNull($game->activeDieArrayArray[1][1]->value);
        $this->assertNotNull($game->activeDieArrayArray[1][2]->value);
        $this->assertNotNull($game->activeDieArrayArray[1][3]->value);
        $this->assertNotNull($game->activeDieArrayArray[1][4]->value);


        // round 1, turn 1
        // player 1: [8 10 12 20 19] showing [8 1 10 15 7], captured []
        // player 2: [4 6 8 4 4] showing [2 3 8 4 1], captured []
        // player 2 takes player 1's d10
        // check that the player with initiative is set as the attacking player
        $this->assertEquals($game->activePlayerIdx, $game->playerWithInitiativeIdx);

        // artificially set player 2 as winning initiative
        $game->playerWithInitiativeIdx = 1;
        $game->activePlayerIdx = 1;
        $game->waitingOnActionArray = array(FALSE, TRUE);
        // artificially set die values
        $dieArrayArray = $game->activeDieArrayArray;
        $dieArrayArray[0][0]->value = 8;
        $dieArrayArray[0][1]->value = 1;
        $dieArrayArray[0][2]->value = 10;
        $dieArrayArray[0][3]->value = 15;
        $dieArrayArray[0][4]->value = 7;
        $dieArrayArray[1][0]->value = 2;
        $dieArrayArray[1][1]->value = 3;
        $dieArrayArray[1][2]->value = 8;
        $dieArrayArray[1][3]->value = 4;
        $dieArrayArray[1][4]->value = 1;

        $this->assertEquals(8, $game->activeDieArrayArray[0][0]->value);

        // perform attack
        $this->assertNULL($game->attack);
        $game->attack = array(1,        // attackerPlayerIdx
                              0,        // defenderPlayerIdx
                              array(2), // attackerAttackDieIdxArray
                              array(1), // defenderAttackDieIdxArray
                              'power'); // attackType

        $game->proceed_to_next_user_action();
        $this->assertEquals(array(TRUE, FALSE), $game->waitingOnActionArray);
        $this->assertEquals(BMGameState::startTurn, $game->gameState);
        $this->assertEquals(4, count($game->activeDieArrayArray[0]));
        $this->assertEquals(5, count($game->activeDieArrayArray[1]));
        $this->assertEquals(0, count($game->capturedDieArrayArray[0]));
        $this->assertEquals(1, count($game->capturedDieArrayArray[1]));
        $this->assertEquals(10, $game->capturedDieArrayArray[1][0]->max);
        $this->assertEquals(1, $game->capturedDieArrayArray[1][0]->value);

        // artificially set value of rolled die
        $dieArrayArray = $game->activeDieArrayArray;
        $dieArrayArray[1][2]->value = 5;

        // round 1, turn 2
        // player 1: [8 12 20 19] showing [8 10 15 7], captured []
        // player 2: [4 6 8 4 4] showing [2 3 5 4 1], captured [10]
        // player 1 takes player 2's d8 with a power attack
        $this->assertEquals(0, $game->activePlayerIdx);
        $this->assertFalse(isset($game->attack));

        $this->assertEquals(8, $game->activeDieArrayArray[0][0]->value);
        $this->assertEquals(10, $game->activeDieArrayArray[0][1]->value);
        $this->assertEquals(15, $game->activeDieArrayArray[0][2]->value);
        $this->assertEquals(7, $game->activeDieArrayArray[0][3]->value);
        $this->assertEquals(2, $game->activeDieArrayArray[1][0]->value);
        $this->assertEquals(3, $game->activeDieArrayArray[1][1]->value);
        $this->assertEquals(5, $game->activeDieArrayArray[1][2]->value);
        $this->assertEquals(4, $game->activeDieArrayArray[1][3]->value);
        $this->assertEquals(1, $game->activeDieArrayArray[1][4]->value);

        // perform attack
        $this->assertNull($game->attack);
        $game->attack = array(0,        // attackerPlayerIdx
                              1,        // defenderPlayerIdx
                              array(3), // attackerAttackDieIdxArray
                              array(2), // defenderAttackDieIdxArray
                              'power'); // attackType
        $game->proceed_to_next_user_action();
        $this->assertEquals(1, $game->activePlayerIdx);
        $this->assertEquals(array(FALSE, TRUE), $game->waitingOnActionArray);
        $this->assertEquals(BMGameState::startTurn, $game->gameState);
        $this->assertEquals(4, count($game->activeDieArrayArray[0]));
        $this->assertEquals(4, count($game->activeDieArrayArray[1]));
        $this->assertEquals(1, count($game->capturedDieArrayArray[0]));
        $this->assertEquals(1, count($game->capturedDieArrayArray[1]));
        $this->assertEquals(8, $game->capturedDieArrayArray[0][0]->max);
        $this->assertEquals(5, $game->capturedDieArrayArray[0][0]->value);
        $this->assertEquals(10, $game->capturedDieArrayArray[1][0]->max);
        $this->assertEquals(1, $game->capturedDieArrayArray[1][0]->value);

        // artificially set value of rolled die
        $dieArrayArray = $game->activeDieArrayArray;
        $dieArrayArray[0][3]->value = 16;

        // round 1, turn 3
        // player 1: [8 12 20 19] showing [8 10 15 16], captured [8]
        // player 2: [4 6 4 4] showing [2 3 4 1], captured [10]
        // player 2 takes player 1's d8 with a skill attack
        $game->attack = array(1,        // attackerPlayerIdx
                              0,        // defenderPlayerIdx
                              array(1, 2, 3), // attackerAttackDieIdxArray
                              array(0), // defenderAttackDieIdxArray
                              'skill'); // attackType
        $game->proceed_to_next_user_action();
        $this->assertEquals(0, $game->activePlayerIdx);
        $this->assertEquals(array(TRUE, FALSE), $game->waitingOnActionArray);
        $this->assertEquals(BMGameState::startTurn, $game->gameState);
        $this->assertEquals(3, count($game->activeDieArrayArray[0]));
        $this->assertEquals(4, count($game->activeDieArrayArray[1]));
        $this->assertEquals(1, count($game->capturedDieArrayArray[0]));
        $this->assertEquals(2, count($game->capturedDieArrayArray[1]));
        $this->assertEquals(8, $game->capturedDieArrayArray[0][0]->max);
        $this->assertEquals(5, $game->capturedDieArrayArray[0][0]->value);
        $this->assertEquals(10, $game->capturedDieArrayArray[1][0]->max);
        $this->assertEquals(1, $game->capturedDieArrayArray[1][0]->value);
        $this->assertEquals(8, $game->capturedDieArrayArray[1][1]->max);
        $this->assertEquals(8, $game->capturedDieArrayArray[1][1]->value);

        // artificially set value of rolled dice
        $dieArrayArray = $game->activeDieArrayArray;
        $dieArrayArray[1][1]->value = 1;
        $dieArrayArray[1][2]->value = 3;
        $dieArrayArray[1][3]->value = 2;

        // round 1, turn 4
        // player 1: [12 20 19] showing [10 15 16], captured [8]
        // player 2: [4 6 4 4] showing [2 1 3 2], captured [10 8]
        // player 2 takes player 1's d4 showing 3 with a power attack

        $game->attack = array(0,        // attackerPlayerIdx
                              1,        // defenderPlayerIdx
                              array(1), // attackerAttackDieIdxArray
                              array(2), // defenderAttackDieIdxArray
                              'power'); // attackType

        $game->proceed_to_next_user_action();
        $this->assertEquals(1, $game->activePlayerIdx);
        $this->assertEquals(array(FALSE, TRUE), $game->waitingOnActionArray);
        $this->assertEquals(BMGameState::startTurn, $game->gameState);
        $this->assertEquals(3, count($game->activeDieArrayArray[0]));
        $this->assertEquals(3, count($game->activeDieArrayArray[1]));
        $this->assertEquals(2, count($game->capturedDieArrayArray[0]));
        $this->assertEquals(2, count($game->capturedDieArrayArray[1]));
        $this->assertEquals(8, $game->capturedDieArrayArray[0][0]->max);
        $this->assertEquals(5, $game->capturedDieArrayArray[0][0]->value);
        $this->assertEquals(4, $game->capturedDieArrayArray[0][1]->max);
        $this->assertEquals(3, $game->capturedDieArrayArray[0][1]->value);
        $this->assertEquals(10, $game->capturedDieArrayArray[1][0]->max);
        $this->assertEquals(1, $game->capturedDieArrayArray[1][0]->value);
        $this->assertEquals(8, $game->capturedDieArrayArray[1][1]->max);
        $this->assertEquals(8, $game->capturedDieArrayArray[1][1]->value);

        // artificially set value of rolled die
        $dieArrayArray = $game->activeDieArrayArray;
        $dieArrayArray[0][1]->value = 9;

        // round 1, turn 5
        // player 1: [12 20 19] showing [10 9 16], captured [8 4]
        // player 2: [4 6 4] showing [2 1 2], captured [10 8]
        // player 2 is forced to pass

        $game->attack = array(1,        // attackerPlayerIdx
                              0,        // defenderPlayerIdx
                              array(), // attackerAttackDieIdxArray
                              array(), // defenderAttackDieIdxArray
                              'pass'); // attackType
        $game->proceed_to_next_user_action();
        $this->assertEquals(0, $game->activePlayerIdx);
        $this->assertEquals(array(TRUE, FALSE), $game->waitingOnActionArray);
        $this->assertEquals(BMGameState::startTurn, $game->gameState);
        $this->assertEquals(3, count($game->activeDieArrayArray[0]));
        $this->assertEquals(3, count($game->activeDieArrayArray[1]));
        $this->assertEquals(2, count($game->capturedDieArrayArray[0]));
        $this->assertEquals(2, count($game->capturedDieArrayArray[1]));
        $this->assertEquals(8, $game->capturedDieArrayArray[0][0]->max);
        $this->assertEquals(5, $game->capturedDieArrayArray[0][0]->value);
        $this->assertEquals(4, $game->capturedDieArrayArray[0][1]->max);
        $this->assertEquals(3, $game->capturedDieArrayArray[0][1]->value);
        $this->assertEquals(10, $game->capturedDieArrayArray[1][0]->max);
        $this->assertEquals(1, $game->capturedDieArrayArray[1][0]->value);
        $this->assertEquals(8, $game->capturedDieArrayArray[1][1]->max);
        $this->assertEquals(8, $game->capturedDieArrayArray[1][1]->value);

        // perform end of round scoring

        // round 2

        // perform end of round scoring

        // round 3

        // perform end of round scoring

        // round 4

        // perform end of round scoring

        // perform end of game actions
    }

}
