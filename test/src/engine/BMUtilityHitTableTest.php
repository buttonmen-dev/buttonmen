<?php
/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2013-01-29 at 13:10:57.
 */

class BMUtilityHitTableTest extends PHPUnit\Framework\TestCase {
    /**
     * @var BMUtilityHitTable
     */
    protected $object;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp() : void
    {
        $die1 = BMDie::create(6);
        $die1->value = 2;
        $die2 = BMDie::create(10);
        $die2->value = 8;
        $die3 = BMDie::create(16);
        $die3->value = 1;
        $die4 = BMDie::create(20);
        $die4->value = 18;

        $this->object = new BMUtilityHitTable(array($die1, $die2, $die3, $die4));
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown() : void
    {
    }

    /**
     * @covers BMUtilityHitTable::find_hit
     * @covers BMUtilityHitTable::__construct
     */
    public function testFind_hit()
    {
        // 2, 8, 1, 18 can combine to make:
        $hits = array(1, 2, 3, 8, 9, 10, 11, 18, 19, 20, 21, 26, 27, 28, 29);

        for ($i = -64; $i < 64; $i++) {
            if (in_array($i, $hits)) {
                $this->assertTrue(TRUE == $this->object->find_hit($i));
                $ret = $this->object->find_hit($i);
                $this->assertEquals(1, count($ret));
            } else {
                $this->assertFalse(TRUE == $this->object->find_hit($i));
            }
        }

        foreach (array(1, 2, 8, 18) as $i) {
            $ret = $this->object->find_hit($i);
            $this->assertEquals(1, count($ret[0]));
            $sum = 0;
            foreach ($ret[0] as $die) {
                $sum += $die->value;
            }
            $this->assertEquals($i, $sum);
        }

        foreach (array(3, 9, 10, 19, 20, 26) as $i) {
            $ret = $this->object->find_hit($i);
            $this->assertEquals(2, count($ret[0]));
            $sum = 0;
            foreach ($ret[0] as $die) {
                $sum += $die->value;
            }
            $this->assertEquals($i, $sum);
        }

        foreach (array(11, 21, 27, 28) as $i) {
            $ret = $this->object->find_hit($i);
            $this->assertEquals(3, count($ret[0]));
            $sum = 0;
            foreach ($ret[0] as $die) {
                $sum += $die->value;
            }
            $this->assertEquals($i, $sum);
        }

        foreach (array(29) as $i) {
            $ret = $this->object->find_hit($i);
            $this->assertEquals(4, count($ret[0]));
            $sum = 0;
            foreach ($ret[0] as $die) {
                $sum += $die->value;
            }
            $this->assertEquals($i, $sum);
        }

        // More complex setups

        // Overlap
        $die1 = BMDie::create(1);
        $die1->value = 1;
        $die2 = BMDie::create(2);
        $die2->value = 1;
        $die3 = BMDie::create(3);
        $die3->value = 1;

        $ht = new BMUtilityHitTable(array($die1, $die2, $die3));

        $ret = $ht->find_hit(1);
        $this->assertEquals(3, count($ret));
        foreach (array($die1, $die2, $die3) as $targetdie) {
            $hit = 0;
            foreach ($ret as $combo) {
                foreach ($combo as $die) {
                    if ($targetdie === $die) {
                        $hit++;
                    }
                }
            }
            $this->assertEquals(1, $hit);
        }

        $ret = $ht->find_hit(2);
        $this->assertEquals(3, count($ret));
        foreach (array($die1, $die2, $die3) as $targetdie) {
            $hit = 0;
            foreach ($ret as $combo) {
                foreach ($combo as $die) {
                    if ($targetdie === $die) {
                        $hit++;
                    }
                }
            }
            $this->assertEquals(2, $hit);
        }

        $ret = $ht->find_hit(3);
        $this->assertEquals(1, count($ret));
        foreach (array($die1, $die2, $die3) as $targetdie) {
            $hit = 0;
            foreach ($ret as $combo) {
                foreach ($combo as $die) {
                    if ($targetdie === $die) {
                        $hit++;
                    }
                }
            }
            $this->assertEquals(1, $hit);
        }

        // Multi-value dice
        $die1 = BMDie::create(10,
                     array("TestDummyBMSkillTestStinger" => "TestStinger"));
        $die1->value = 10;
        $die2 = BMDie::create(6);
        $die2->value = 6;

        $ht = new BMUtilityHitTable(array($die1, $die2));

        // Two ways to make 6-10, one for all the rest
        foreach (array(6, 7, 8, 9, 10) as $i) {
            $ret = $ht->find_hit($i);
            $this->assertEquals(2, count($ret));
            foreach ($ret as $combo) {
                $this->assertTrue(count($combo) > 0 && count($combo) < 3);
                if ($i == 6) {
                    // 6 is a special case, as it's the only die1 or die2
                    $this->assertEquals(1, count($combo));
                } else {
                    if (count($combo) == 2) {
                        $this->assertContains($die1, $combo);
                        $this->assertContains($die2, $combo);
                    } else {
                        $this->assertEquals(1, count($combo));
                        $this->assertContains($die1, $combo);
                    }
                }
            }
            if ($i == 6) {
                $this->assertTrue($ret[0][0] === $die1 ||
                                  $ret[1][0] === $die1);
                $this->assertTrue($ret[0][0] === $die2 ||
                                  $ret[1][0] === $die2);
            }
        }

        // made with just die1
        foreach (array(1, 2, 3, 4, 5) as $i) {
            $ret = $ht->find_hit($i);
            $this->assertEquals(1, count($ret));
            $this->assertEquals(1, count($ret[0]));
            $this->assertContains($die1, $ret[0]);
        }

        // made with both
        foreach (array(11, 12, 13, 14, 15, 16) as $i) {
            $ret = $ht->find_hit($i);
            $this->assertEquals(1, count($ret));
            $this->assertEquals(2, count($ret[0]));
            $this->assertContains($die1, $ret[0]);
            $this->assertContains($die2, $ret[0]);
        }



        $die1 = BMDie::create(10,
                    array("TestDummyBMSkillTestStinger" => "TestStinger"));
        $die1->value = 10;
        $die2 = BMDie::create(6,
                    array("TestDummyBMSkillTestStinger" => "TestStinger"));
        $die2->value = 6;

        $ht = new BMUtilityHitTable(array($die1, $die2));

        // One way to make 11-16
        foreach (array(11, 12, 13, 14, 15, 16) as $i) {
            $ret = $ht->find_hit($i);
            $this->assertEquals(1, count($ret));
            $this->assertEquals(2, count($ret[0]));
            $this->assertContains($die1, $ret[0]);
            $this->assertContains($die2, $ret[0]);
        }

        // Two ways to make 7-10
        foreach (array(7, 8, 9, 10) as $i) {
            $ret = $ht->find_hit($i);
            $this->assertEquals(2, count($ret));
            foreach ($ret as $combo) {
                $this->assertTrue(count($combo) > 0 && count($combo) < 3);
                if (count($combo) == 2) {
                    $this->assertContains($die1, $combo);
                    $this->assertContains($die2, $combo);
                } else {
                    $this->assertEquals(1, count($combo));
                    $this->assertContains($die1, $combo);
                }
            }
        }

        // two ways to make 1
        $ret = $ht->find_hit(1);
        $this->assertEquals(2, count($ret));
        $this->assertTrue($ret[0][0] === $die1 ||
                          $ret[1][0] === $die1);
        $this->assertTrue($ret[0][0] === $die2 ||
                          $ret[1][0] === $die2);


        // Three ways to make 2-6
        foreach (array(2, 3, 4, 5, 6) as $i) {
            $found1 = FALSE;
            $found2 = FALSE;
            $ret = $ht->find_hit($i);
            $this->assertEquals(3, count($ret));
            foreach ($ret as $combo) {
                $this->assertTrue(count($combo) > 0 && count($combo) < 3);
                if (count($combo) == 2) {
                    $this->assertContains($die1, $combo);
                    $this->assertContains($die2, $combo);
                } else {
                    if ($combo[0] === $die1) { $found1 = TRUE; }
                    if ($combo[0] === $die2) { $found2 = TRUE; }
                }
            }
            $this->assertTrue($found1 && $found2);
        }
    }

    /**
     * @covers BMUtilityHitTable::find_hit
     * @covers BMUtilityHitTable::__construct
     * @covers BMUtilityHitTable::__get
     * @covers BMSkillKonstant::hit_table
     */
    public function testFind_hit_konstant()
    {
        $die1 = BMDie::create(6);
        $die1->value = 2;
        $die1->add_skill('Konstant');

        $die2 = BMDie::create(10);
        $die2->value = 8;

        $die3 = BMDie::create(16);
        $die3->value = 1;
        $die3->add_skill('Konstant');


        $hitTable = new BMUtilityHitTable(array($die1));
        $this->assertCount(0, $hitTable->hits);

        $hitTable = new BMUtilityHitTable(array($die1, $die2));
        $hitValues = array_keys($hitTable->hits);
        $this->assertCount(3, $hitValues);
        sort($hitValues);
        $this->assertEquals(array(6, 8, 10), $hitValues);

        $hitTable = new BMUtilityHitTable(array($die1, $die3));
        $hitValues = array_keys($hitTable->hits);
        $this->assertCount(4, $hitValues);
        sort($hitValues);
        $this->assertEquals(array(-3, -1, 1, 3), $hitValues);
    }

    /**
     * @covers BMUtilityHitTable::list_hits
     * @covers BMUtilityHitTable::__construct
     */
    public function testList_hits()
    {
        // 2, 8, 1, 18 can combine to make:
        $hits = array(1, 2, 3, 8, 9, 10, 11, 18, 19, 20, 21, 26, 27, 28, 29);

        for ($i = -64; $i < 64; $i++) {
            if (in_array($i, $hits)) {
                $this->assertContains($i, $this->object->list_hits());
            } else {
                $this->assertNotContains($i, $this->object->list_hits());
            }
        }

        // More complex setups

        // Overlap
        $die1 = BMDie::create(1);
        $die1->value = 1;
        $die2 = BMDie::create(2);
        $die2->value = 1;
        $die3 = BMDie::create(3);
        $die3->value = 1;

        $ht = new BMUtilityHitTable(array($die1, $die2, $die3));

        for ($i = 1; $i <= 3; $i++) {
            $this->assertContains($i, $ht->list_hits());
        }

        $this->assertEquals(3, count($ht->list_hits()));

        // Multi-value dice
        $die1 = BMDie::create(4,
                    array("TestDummyBMSkillTestStinger" => "TestStinger"));
        $die1->value = 4;
        $die2 = BMDie::create(6);
        $die2->value = 6;


        $ht = new BMUtilityHitTable(array($die1, $die2));

        for ($i = -64; $i < 64; $i++) {
            // They should cover 1-4, 6-10
            if ($i != 5 && $i > 0 && $i < 11) {
                $this->assertContains($i, $ht->list_hits());
            } else {
                $this->assertNotContains($i, $ht->list_hits());
            }
        }


        $die1 = BMDie::create(4,
                    array("TestDummyBMSkillTestStinger" => "TestStinger"));
        $die1->value = 4;
        $die2 = BMDie::create(8,
                    array("TestDummyBMSkillTestStinger" => "TestStinger"));
        $die2->value = 8;

        $ht = new BMUtilityHitTable(array($die1, $die2));

        for ($i = -64; $i < 64; $i++) {
            // They should cover 1-12
            if ($i > 0 && $i < 13) {
                $this->assertContains($i, $ht->list_hits());
            } else {
                $this->assertNotContains($i, $ht->list_hits());
            }
        }
    }

    /**
     * @covers BMUtilityHitTable::__set
     */
    public function testSet()
    {
        try {
            $this->object->hits = NULL;
            $this->fail('Cannot set private properties.');
        } catch (LogicException $e) {
        }
    }
}
